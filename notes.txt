Progress: I have a test2 username and password 123 account for testing purpose. Registered my personal email. 
test username and password 1234 with wisc email

import flask-security will have conflict with flask-login

my table user is mysteriously not found 1/20/24, which is concerning because that meant my database is corrupted some way and 
I don't know why. I used flask db migrate and flask db upgrade but it just erased everything including the old data. I don't where it all went.
当你在一个新PC上时，你需要保证你的Flask和pip是最新的，在Windows可能会报错Fatal error in launcher，强制你在每个指令前加上python -m。你还需要保证重新创建database用相应的指令，不然会报错OperationalError
sqlalchemy.exc.OperationalError。

nano .gitignore

IMPORTANT!!!
conda activate watchlist
to activate env (windows): . env/Scripts/activate
to activate env (mac/linux): . env/bin/activate 
to start the app in test mode: flask run
export EMAIL_USER='wldemo.noreply@gmail.com'
export EMAIL_PASS='watchlist app password'

Seems that you need to redo below steps upon changing to a new computer:
pip install flask flask_sqlalchemy flask_wtf wtforms flask_bootstrap flask_login flask_mail flask_migrate
pip install -U Werkzeug
pip install -U bootstrap-flask
pip install flask-security (N/A)
pip install email_validator

I need to user python3 to start python shell in terminal, which is a bit annoying.


flask db init [Run this first time you create your application]
[Below run it everytime you update your models]
flask db migrate
flask db upgrade

Delete all users:
1. flask shell
2. from app import db, User
3. User.query.delete()
4. db.session.commit()
5. exit()

Add attributes after updating the model:
1. flask shell
2. from app import db, User
3. users = User.query.all()
4. >>> for user in users:
...     if not hasattr(user, 'email_confirmed'):
...         user.email_confirmed = False
...
[for this, you need to copy each line with indentation, and press Enter]
[Use quit() or Ctrl-D (i.e. EOF) to exit]
5. db.session.commit()

https://stackoverflow.com/questions/23039734/flask-login-password-reset
https://flask-security-too.readthedocs.io/en/stable/index.html

Name: wl-demo
sender: wldemo.noreply@gmail.com
https://stackoverflow.com/questions/37058567/configure-flask-mail-to-use-gmail
https://domar.com/pages/smtp_pop3_server

Email Confirmation: Sending a confirmation email that contains a link for the user to click is a standard way to confirm an email address. When the user clicks the link, you can mark their email as confirmed in your system.

Access to Features: You can allow users to access certain features of your application even if they haven’t confirmed their email address. However, any features that involve sending emails to the user should require email confirmation. This includes any notifications, password reset links, or other sensitive information.

Reminders: If a user doesn’t confirm their email address, you can periodically remind them to do so. This could be a message displayed when they log in, or a reminder sent to their email address.

Account Deletion: Some applications choose to delete accounts that haven’t confirmed their email address after a certain period of time. This can help keep your user database clean.

Resend Confirmation Link: It’s a good idea to provide an option for users to resend the confirmation link in case they didn’t receive it or it expired.

--- 
Thoughts: "Limited Access Until Confirmation" -> For any email-sending features, disable it until the user has confirmed their email. 
Restrict Access Until Confirmation: Some applications do not allow users to log in until they have confirmed their email address. This is often the case for applications where email is a critical part of the user interaction, such as those involving financial transactions, sensitive data, or important notifications.

Limited Access Until Confirmation: Other applications allow users to log in immediately after registration, but limit access to certain features until the email address has been confirmed. This is a common practice in applications where not all features require a verified email.

Full Access with Reminder to Confirm: Some applications allow full access after registration, but continue to remind the user to confirm their email address. This is often seen in less critical applications or in cases where the user experience is prioritized over strict security measures.


1/12: AttributeError: module 'hashlib' has no attribute 'scrypt': by following this:
brew install openssl
echo 'export PATH="/usr/local/opt/openssl/bin:$PATH"' >> ~/.bash_profile
source ~/.bash_profile
and create a new env and reinstall every dependencies 
https://stackoverflow.com/questions/35129977/how-to-install-latest-version-of-openssl-mac-os-x-el-capitan

Gave up 10/19: 你可以把删除按钮的行内 JavaScript 代码改为事件监听函数，写到单独的 JavaScript 文件里。再进一步，你也可以使用 JavaScript 来监听点击删除按钮的动作，并发送删除条目的 POST 请求，这样删除按钮就可以使用普通 <a> 标签（CSRF 令牌存储在元素属性里），而不用创建表单元素。

<!-- <form class="inline-form" method="post" action="{{ url_for('delete', movie_id=movie.id) }}"> -->
    <input class="btn" type="submit" name="delete" value="Delete" id="del-btn">
<!-- </form> -->

// // 把删除按钮的行内 JavaScript 代码改为事件监听函数，写到单独的 JavaScript 文件里
// var deleteButton = document.getElementById("del_btn"); // select the input element by id
// deleteButton.addEventListener("click", function() { // add a click event listener
//   return confirm("Are you sure?"); // show a confirmation dialog and return its result
// });

<!-- <a class="btn del-btn" data-movie-id="{{ movie.id }}">Delete</a> use a class and a data attribute instead of an id -->

// // JavaScript file
// window.addEventListener("DOMContentLoaded", function() {
//     var deleteButtons = document.getElementsByClassName("del-btn"); // select all the elements with the del-btn class
//     for (var i = 0; i < deleteButtons.length; i++) { // loop through the array-like object
//       var deleteButton = deleteButtons[i]; // get the current element
//       deleteButton.addEventListener("click", function() { // add a click event listener
//         var xhr = new XMLHttpRequest(); // create a new XMLHttpRequest object
//         var movieId = this.getAttribute("data-movie-id"); // get the movie id from the data attribute
//         var url = "/delete/<movie_id>"; // use a placeholder in the URL
//         url = url.replace("<movie_id>", movieId); // replace the placeholder with the actual movie id
//         xhr.open("POST", url, true); // set up the request
//         xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); // set the request header
//         var data = "delete=Delete&movie_id=" + movieId; // prepare the data
//         xhr.send(data); // send the request
//         xhr.onload = function() { // handle the response
//           if (xhr.status == 200) { // if successful
//             alert("Movie deleted successfully!"); // show a message
//             window.location.reload(); // reload the page
//           } else { // if not successful
//             alert("Something went wrong!"); // show an error message
//           }
//         };
//       });
//     }
//   });